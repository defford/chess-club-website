import { NextRequest, NextResponse } from 'next/server';
import { googleSheetsService } from '@/lib/googleSheets';
import { GameData, GameFormData, BulkGameData } from '@/lib/types';
import { requireAdminAuth } from '@/lib/apiAuth';

// GET /api/games - List all games with optional filters
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // Parse query parameters for filtering
    const filters = {
      playerId: searchParams.get('playerId') || undefined,
      gameType: searchParams.get('gameType') || undefined,
      dateFrom: searchParams.get('dateFrom') || undefined,
      dateTo: searchParams.get('dateTo') || undefined,
      result: searchParams.get('result') || undefined,
      eventId: searchParams.get('eventId') || undefined,
      isVerified: searchParams.get('isVerified') ? searchParams.get('isVerified') === 'true' : undefined,
    };

    // Remove undefined values
    const cleanFilters = Object.fromEntries(
      Object.entries(filters).filter(([_, value]) => value !== undefined)
    );

    const games = await googleSheetsService.getGames(cleanFilters);
    
    return NextResponse.json(games);
  } catch (error) {
    console.error('Games API GET error:', error);
    return NextResponse.json(
      { error: 'Failed to retrieve games' },
      { status: 500 }
    );
  }
}

// POST /api/games - Create a new game
export async function POST(request: NextRequest) {
  try {
    // Check admin authentication
    const authResult = await requireAdminAuth(request);
    if (!authResult.isAdmin) {
      return NextResponse.json(
        { error: authResult.error || 'Admin privileges required' },
        { status: 403 }
      );
    }

    const gameFormData: GameFormData = await request.json();
    
    // Validate required fields
    if (!gameFormData.player1Id || !gameFormData.player2Id || !gameFormData.result) {
      return NextResponse.json(
        { error: 'Missing required fields: player1Id, player2Id, result' },
        { status: 400 }
      );
    }

    if (gameFormData.player1Id === gameFormData.player2Id) {
      return NextResponse.json(
        { error: 'Players must be different' },
        { status: 400 }
      );
    }

    if (!['player1', 'player2', 'draw'].includes(gameFormData.result)) {
      return NextResponse.json(
        { error: 'Invalid result. Must be player1, player2, or draw' },
        { status: 400 }
      );
    }

    // Get player names
    const players = await googleSheetsService.getPlayers();
    const player1 = players.find(p => p.id === gameFormData.player1Id);
    const player2 = players.find(p => p.id === gameFormData.player2Id);

    if (!player1 || !player2) {
      return NextResponse.json(
        { error: 'One or both players not found' },
        { status: 404 }
      );
    }

    // Create game data object
    const gameData: GameData = {
      id: '', // Will be generated by addGame
      player1Id: gameFormData.player1Id,
      player1Name: player1.name,
      player2Id: gameFormData.player2Id,
      player2Name: player2.name,
      result: gameFormData.result,
      gameDate: gameFormData.gameDate || new Date().toISOString().split('T')[0],
      gameTime: gameFormData.gameTime || 0,
      gameType: gameFormData.gameType || 'ladder',
      eventId: gameFormData.eventId,
      notes: gameFormData.notes,
      recordedBy: 'admin', // TODO: Get from auth context
      recordedAt: new Date().toISOString(),
      opening: gameFormData.opening,
      endgame: gameFormData.endgame,
      isVerified: false,
    };

    // Add game to Google Sheets
    const gameId = await googleSheetsService.addGame(gameData);

    // Update player statistics
    await updatePlayerStats(gameFormData.player1Id, gameFormData.player2Id, gameFormData.result);

    return NextResponse.json(
      { 
        message: 'Game created successfully',
        gameId,
        game: { ...gameData, id: gameId }
      },
      { status: 201 }
    );
  } catch (error) {
    console.error('Games API POST error:', error);
    return NextResponse.json(
      { error: 'Failed to create game' },
      { status: 500 }
    );
  }
}

// Helper function to update player statistics
async function updatePlayerStats(player1Id: string, player2Id: string, result: string) {
  try {
    const players = await googleSheetsService.getPlayers();
    const player1 = players.find(p => p.id === player1Id);
    const player2 = players.find(p => p.id === player2Id);

    if (!player1 || !player2) {
      throw new Error('Players not found for stats update');
    }

    // Calculate new points based on scoring system:
    // Each player gets 1 point for playing
    // Winner gets +1 additional point (total 2)
    // Draw: each player gets +0.5 additional point (total 1.5 each)
    
    let player1Points = player1.points + 1; // Base point for playing
    let player2Points = player2.points + 1; // Base point for playing
    
    let player1Wins = player1.wins;
    let player1Losses = player1.losses;
    let player2Wins = player2.wins;
    let player2Losses = player2.losses;

    if (result === 'player1') {
      // Player 1 wins
      player1Points += 1; // Additional point for winning
      player1Wins += 1;
      player2Losses += 1;
    } else if (result === 'player2') {
      // Player 2 wins
      player2Points += 1; // Additional point for winning
      player2Wins += 1;
      player1Losses += 1;
    } else {
      // Draw - each player gets 0.5 additional points
      player1Points += 0.5;
      player2Points += 0.5;
    }

    // Update both players
    await googleSheetsService.updatePlayer(player1Id, {
      wins: player1Wins,
      losses: player1Losses,
      points: player1Points,
      lastActive: new Date().toISOString()
    });

    await googleSheetsService.updatePlayer(player2Id, {
      wins: player2Wins,
      losses: player2Losses,
      points: player2Points,
      lastActive: new Date().toISOString()
    });

    // Recalculate rankings after updating both players
    await googleSheetsService.recalculateRankings();
  } catch (error) {
    console.error('Error updating player stats:', error);
    throw error;
  }
}
